% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_blockpoints_in_shape.R
\name{get_blockpoints_in_shape}
\alias{get_blockpoints_in_shape}
\alias{shapefile2blockpoints}
\title{Find all Census blocks in a polygon, using internal point of block}
\usage{
get_blockpoints_in_shape(
  polys,
  addedbuffermiles = 0,
  blocksnearby = NULL,
  dissolved = FALSE,
  safety_margin_ratio = 1.1,
  crs = 4269,
  updateProgress = NULL,
  oldway = TRUE
)
}
\arguments{
\item{polys}{Spatial data as from sf::st_as_sf(), with
points as from \code{\link[=shapefile_from_sitepoints]{shapefile_from_sitepoints()}},
or a table of points with lat,lon columns that will first be converted here using that function,
or polygons}

\item{addedbuffermiles}{width of optional buffering to add to the points (or edges), in miles}

\item{blocksnearby}{optional table of blocks with blockid, etc (from which lat,lon can be looked up in blockpoints dt)}

\item{dissolved}{If TRUE, use sf::st_union(polys) to find unique blocks inside any one or more of polys}

\item{safety_margin_ratio}{multiplied by addedbuffermiles, how far to search for
blocks nearby using getblocksnearby(), before using those found to do the intersection via sf::}

\item{crs}{used in st_as_sf() and st_transform() and shape_buffered_from_shapefile_points(), crs = 4269 or Geodetic CRS NAD83}

\item{updateProgress}{optional Shiny progress bar to update}

\item{oldway}{whether to use older method that works but may be slower vs newer/draft}
}
\value{
Block points table for those blocks whose internal point is inside the buffer
which is just a circular buffer of specified radius if polys are just points.
This is like the output of  \code{\link[=getblocksnearby]{getblocksnearby()}}, or \code{\link[=getblocksnearby_from_fips]{getblocksnearby_from_fips()}} if return_shp=F.

The ejam_uniq_id represents which of the input sites is being referred to, and the table
will only have the ids of the sites where blocks were found. If 10 sites were input but only sites 5 and 8
were valid and had blocks identified, then the data.table here will only include ejam_uniq_id values of 5 and 8.
}
\description{
Like \code{\link[=getblocksnearby]{getblocksnearby()}}, but for blocks in each polygon rather than
blocks near each facility. For analyzing all residents in certain zones
such as places at elevated risk, redlined areas, watersheds, etc.
}
\details{
This uses getblocksnearby() to get a very fast rough/good estimate of
which US block points are nearby (with a safety margin - see param below),
before then using sf:: to carefully identify which of those candidate blocks are actually
inside each polygon (e.g., circle) according to sf:: methods.

For circular buffers, just using getblocksnearby() should work and not need this function.

For non-circular polygons, buffered or not, this function will provide a way to very quickly
filter down to which of the millions of US blocks should be examined by the sf:: join / intersect,
since otherwise it takes forever for sf:: to check all US blocks.
}
\examples{
  # y <- get_blockpoints_in_shape()

  # x = shapefile_from_sitepoints(testpoints_n(2))
  # y = get_blockpoints_in_shape(x, 1)  # very very slow
}
\seealso{
\code{\link[=getblocksnearby]{getblocksnearby()}}  \code{\link[=getblocksnearby_from_fips]{getblocksnearby_from_fips()}}  \code{\link[=shapefile_from_sitepoints]{shapefile_from_sitepoints()}} \code{\link[=shape_buffered_from_shapefile_points]{shape_buffered_from_shapefile_points()}}
}
