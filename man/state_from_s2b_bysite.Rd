% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/state_from_s2b_bysite.R
\name{state_from_s2b_bysite}
\alias{state_from_s2b_bysite}
\title{Get State each site is entirely within, quickly, from table of blocks nearby/at/in each site (via blockid, by ejam_uniq_id)}
\usage{
state_from_s2b_bysite(sites2blocks)
}
\arguments{
\item{sites2blocks}{data.table or data.frame, like \link{testoutput_getblocksnearby_10pts_1miles},
from \code{\link[=getblocksnearby]{getblocksnearby()}} that has columns ejam_uniq_id and blockid and distance}
}
\value{
data.table with columns  ejam_uniq_id, ST
}
\description{
Find the 2-character State abbreviation (ST), but only for sites entirely in 1 state.
}
\details{
This function is for when you need to quickly find out the state each site is in,
to be able to report state percentiles, This can identify the State
each site is located in, based on the states of the nearby blocks (and parent blockgroups).
In many analyses, all the sites will be single-state sites, and this function will be sufficient.
\itemize{
\item This function only identifies the State for each site that is entirely in 1 state
(whose included block internal points are all in the same state).
\item For each multistate site, this returns NA as the ST.
\itemize{
\item For a multistate site defined by radius and latlon (a circular buffer), need lat/lon of site and that is slower,
and handled elsewhere. (And for the rare edge case where you did not save the lat,lon of sites you analyzed,
you would need to approximate those from the lat/lon of the blocks and their distances,
via \code{\link[=latlon_from_s2b]{latlon_from_s2b()}}, separately).
\item For a multistate site defined by a polygon, it is not entirely clear which state to pick for purposes of reporting state percentiles,
but that is handled elsewhere.
}
}

Note this is an unexported function.

Note that the two functions \code{\link[=state_from_blockid_table]{state_from_blockid_table()}} and \code{\link[=state_from_s2b_bysite]{state_from_s2b_bysite()}} differ
-- one gets the state info for each unique SITE,
and the other gets the state abbreviation of each unique BLOCK:

\if{html}{\out{<div class="sourceCode">}}\preformatted{xx = state_from_s2b_bysite(testoutput_getblocksnearby_10pts_1miles)[]
NROW(xx)
# 10
length(unique(testoutput_getblocksnearby_10pts_1miles$ejam_uniq_id))
# 10

length(EJAM:::state_from_blockid_table(testoutput_getblocksnearby_10pts_1miles))
# 1914
NROW(testoutput_getblocksnearby_10pts_1miles)
# 1914
}\if{html}{\out{</div>}}
}
\examples{
\donttest{
# unexported function, so use load_all() or :::
table(state_from_blockid_table(testoutput_getblocksnearby_10pts_1miles))
state_from_s2b_bysite(testoutput_getblocksnearby_10pts_1miles)[]

  x = getblocksnearby(pts, radius = 30)
  y = state_from_s2b_bysite(x)
  table(y$in_how_many_states)
  y

  fname = './inst/testdata/testpoints_207_sites_with_signif_violations_NAICS_326_ECHO.csv'
  x = state_from_s2b_bysite(
    getblocksnearby( latlon_from_anything(fname), quadtree = localtree))
  y = read_csv_or_xl(fname)
  x$ST == y$FacState
  }
  state_from_s2b_bysite(testoutput_getblocksnearby_10pts_1miles)

}
\seealso{
\code{\link[=state_from_blockid_table]{state_from_blockid_table()}} \code{\link[=state_per_site_for_doaggregate]{state_per_site_for_doaggregate()}}
}
\keyword{internal}
